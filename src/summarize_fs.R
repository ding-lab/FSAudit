# Matthew Wyczalkowski
# m.wyczalkowski@wustl.edu
# Ding Lab, Washington University School of Medicine

# Note: summarize_fs2.R is a replacement script for summarize_fs.R,
# developed on a system while an analysis run was taking place.  When this
# is tested and the run stops replace the latter with this.

# Usage: Rscript summarize_fs.sh [options] in.dat out.dat
#
# Process file summary output as generated by parse_fs.py and generate summary data
# by grouping data files by owner and/or extension.  Expected columns of input:
#   dirname, filename, ext, file_type, file_size, owner_name, time_mod, hard_links

# Args:
# -v: verbose output
# -Z: input is a .gz file
# -g group.by: group by "owner_name", "ext", or "ext-owner_name" (default)
# -D bad.fs: evaluate input data in debug mode, and print out the first matching line
#   where file_size as imported is equal to the value bad_fs.  Useful for debugging
#   cases of weird filenames which break upstream parsing.  

library("plyr")

# Return the command line argument associated with a given flag (i.e., -o foo),
# or the default value if argument not specified.
# Note that this will break if an argument is not supplied after the flag.
get_val_arg = function(args, flag, default) {
    ix = pmatch(flag, args)
    if (!is.na(ix)){ val = args[ix+1] } else { val = default }
    return(val)
}

# Return boolean specifying whether given flag appears in command line (i.e., -o),
get_bool_arg = function(args, flag) {
    ix = pmatch(flag, args)
    if (!is.na(ix)){ val = TRUE } else { val = FALSE }
    return(val)
}

# Usage:
#   args = parse_args()
#   print(args$disease.filter)
parse_args = function() {
    args = commandArgs(trailingOnly = TRUE)

    # optional arguments
    verbose = get_bool_arg(args, "-v")
    topN = as.numeric(get_val_arg(args, "-N", 250))
    is.gz = get_bool_arg(args, "-Z")
    group.by = get_val_arg(args, "-g", "ext-owner_name")
    bad.fs = get_val_arg(args, "-D", NULL)

    # mandatory positional arguments.  These are popped off the back of the array, last one listed first.
    out.fn = args[length(args)];   args = args[-length(args)]
    in.fn = args[length(args)];    args = args[-length(args)]

    val = list( 'in.fn'=in.fn, 'verbose'=verbose, 'out.fn'=out.fn, 'topN'=topN, 'is.gz'=is.gz, 'group.by'=group.by, 'bad.fa'=bad.fs)
    if (val$verbose) { print(val) }
    return (val)
}

args = parse_args()

# Read in tsv file and keep only regular file entries
# we are interested only in the following columns:
#   file_size, ext, owner_name
# for large datasets we don't want to store unnecessary data
# look at colClasses: https://stat.ethz.ch/R-manual/R-devel/library/utils/html/read.table.html
#
#  1 SKIP  # dirname
#  2 SKIP  filename
#  3 KEEP  ext
#  4 SKIP  file_type
#  5 KEEP  file_size
#  6 KEEP  owner_name
#  7 SKIP  time_mod
#  8 SKIP  hard_links

if ( is.null(args$bad.fs) ) {
    colClasses=c("NULL", "NULL", "character", "NULL", "numeric", "character", "NULL", "NULL")
} else {
# If there is a malformed filename, script may choke.  To debug, first allow any value for the file_size field.  See below...
    colClasses=c("NULL", "NULL", "character", "NULL", NA, "character", "NULL", "NULL")
}

if (args$is.gz) {
    FSA = read.csv(gzfile(args$in.fn), sep="\t", colClasses=colClasses);
} else {
    FSA = read.csv(args$in.fn, sep="\t", colClasses=colClasses);
}

# From experience, malformed filenames (containing newlines, for instance) can result in 
# a nonsense value in the file_size column (bad.fs).  This is typically detected when it yields fatal error when bad.fs is coerced into an integer
# Here we print out the row corresponding to the first instance of the file size having the value bad.fs
if ( ! is.null( args$bad.fs )) {
    print("DEBUG mode: printing first instance of file_size having value" + args$bad.fs)
    print(FSA[which(FSA$file_size == args$bad.fs), ])
    print("Quitting")
    q()
}

# -g group.by: group by "owner_name", "ext", or "ext-owner_name" (default)
if ( args$group.by == "owner_name" ) {
    rFSA=ddply(FSA, c("owner_name"), summarise,count=length(file_size),cumulative_size=sum(file_size))
} else if ( args$group.by == "ext" ) {
    rFSA=ddply(FSA, c("ext"), summarise,count=length(file_size),cumulative_size=sum(file_size))
} else if ( args$group.by == "ext-owner_name" ) {
    rFSA=ddply(FSA, c("ext","owner_name"), summarise,count=length(file_size),cumulative_size=sum(file_size))
} else {
    print("ERROR Permitted values of group.by are: owner_name, ext, ext-owner_name")
    q()
}

write.table(rFSA, args$out.fn, sep="\t", quote=FALSE, row.names=FALSE)
cat(sprintf("    Saved to %s\n", args$out.fn))


