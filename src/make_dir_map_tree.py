# Matthew Wyczalkowski
# m.wyczalkowski@wustl.edu
# Washington University School of Medicine

# We will write all directories and their size, calculated as the size of all files under them
# version 2 implementation builds an internal directory tree structure then loops over all files

import sys, os, gzip
#import pandas as pd
import datetime

# https://anytree.readthedocs.io/en/stable/intro.html
#from anytree import Node, RenderTree, Resolver, Walker
import anytree


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def add_dir_to_tree(dirpath, root):
# https://anytree.readthedocs.io/en/stable/api/anytree.node.html#anytree.node.node.Node
    parent = root
    for d in dirpath.split("/")[2:]:    # d is direcory name.  nd is node associated with d
        nd = None
        for c in parent.children:   # consider using resolver
            if c.name == d:
                nd = c
                break
        if nd is None:
            nd = anytree.Node(d, parent=parent, dirsize=0)
        parent = nd            

def add_file_to_tree(filepath, filesize, root, resolver, walker):
# use Resolver to get leaf directory
    dirpath = os.path.dirname(filepath)
#    eprint("path, dirpath, size = %s, %s, %d" % (filepath, dirpath, filesize))
#    eprint("root = %s" % root)
    leaf = resolver.get(root, dirpath)
#    eprint("leaf = %s" % leaf)

    # https://anytree.readthedocs.io/en/stable/api/anytree.walker.html
    for n in walker.walk(root, leaf)[2]:
        n.dirsize += filesize

# use walker to go from root to leaf dir, and add filesize to each
#     1 file_name   /rdcw/fs1/m.wyczalkowski/Active/ProjectStorage/Analysis/20230427.SW_vs_TD/dat/call-rescuevaffilter_pindel/rescuevaffilter.cwl
#     4 owner_name  m.wyczalkowski
#     5 time_mod    2023-02-01 18:11:36.000000000 -0600
def make_dirtree(fn, rootNode):
    with gzip.open(fn, mode='rt') as dirlist:
        for i, line in enumerate(dirlist):
#            eprint("Line %d: %s" % (i, line))
            dirpath = line.split("\t")[0]
            add_dir_to_tree(dirpath, rootNode)

#     1	file_name	/rdcw/fs1/m.wyczalkowski/Active/ProjectStorage/Analysis/20230427.SW_vs_TD/dat/call-rescuevaffilter_pindel/rescuevaffilter.cwl/b9ea6316-ce5e-401f-9ff8-dc181ed7db4d/call-somatic_vaf_filter_A/execution/rc
#     3	file_size	2
#     4	owner_name	m.wyczalkowski
#     5	time_mod	2023-02-01 18:11:47.000000000 -0600
def parse_files(fn, rootNode):
    resolver = anytree.Resolver()
    walker = anytree.Walker()
    with gzip.open(fn, mode='rt') as filelist:
        for i, line in enumerate(filelist):
#            eprint("Line %d: %s" % (i, line))
            try:
                tok = line.split("\t")
                filepath = tok[0]# .lstrip("/")
                filesize = int(tok[1])
                # Possibly add filtering here by owner or time
                add_file_to_tree(filepath, filesize, rootNode, resolver, walker)
            except:
                eprint("Error caught in %s line %d\n\t%s\nContinuing" % (fn, i, line))

# https://stackoverflow.com/questions/5194057/better-way-to-convert-file-sizes-in-python
def convert_size(size_bytes):
   if size_bytes == 0:
       return "0B"
   size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
   i = int(math.floor(math.log(size_bytes, 1024)))
   p = math.pow(1024, i)
   s = round(size_bytes / p, 2)
   return "%s %s" % (s, size_name[i])


def write_dirtree(fn, rootNode):
    with open(fn,"w") as f:
        for i, n in enumerate(anytree.LevelOrderIter(rootNode)):
            # node.path is known from code; https://github.com/c0fec0de/anytree/blob/65a5d09ce0a592a80918f094ec3fa48b7faca250/anytree/node/node.py#L82C1-L83C1
            # https://anytree.readthedocs.io/en/stable/api/anytree.node.html#anytree.node.nodemixin.NodeMixin.path
            p = "/".join([""] + [str(nn.name) for nn in n.path])
#            eprint("%s\t%d" % (p, n.dirsize))
            f.write("%s\t%d\n" % (p, n.dirsize))

def main():
    from optparse import OptionParser
    usage_text = """usage: %prog [options] ...
        Process list of generated by stat of file options
        """

    parser = OptionParser(usage_text, version="$Revision: 1.2 $")
    parser.add_option("-e", dest="dirlist", help="List of directories")
    parser.add_option("-f", dest="filelist", help="List of files")
    parser.add_option("-o", dest="outfn", default="stdout", help="Output filename")

    (options, params) = parser.parse_args()

#        eprint("[%s]: tree depth = %d: %d files" % (datetime.datetime.now(), L, len(dirsL.index) ))
    # not clear how to do this with no assumptions about root dir
    rootNode = anytree.Node("rdcw", dirsize=0)
    eprint("[%s] Making dirlist from %s" % (datetime.datetime.now(), options.dirlist))
    make_dirtree(options.dirlist, rootNode)

    eprint("[%s] Parsing files in %s" % (datetime.datetime.now(), options.filelist))
    parse_files(options.filelist, rootNode)

    eprint("[%s] Writing to %s" % (datetime.datetime.now(), options.outfn))
    write_dirtree(options.outfn, rootNode)

#TODO: allow this to write out [dirname, dirsize]


if __name__ == '__main__':
    main()

