#!/bin/bash

# Matthew Wyczalkowski <m.wyczalkowski@wustl.edu>
# https://dinglab.wustl.edu/

read -r -d '' USAGE <<'EOF'
Generate FSAudit filestat data for one volume

Usage:
  process_FS.sh [options] STEP

Options:
-h: Print this help message
-d: dry run: print commands but do not run
-V VOLUME: This is the base path we are analyzing (/gscmnt/gc2737/ding).  Required
-T TIMESTAMP: Date, typically in YYYYMMDD format, used for output filenames.  Default is based on today's date
-N VOLNAME: Short name of system and volume, used for filenames (MGI.gc2737).  Required
-t DATD: directory where analysis data (raw, filestat, summary, plots) is written.  Default : ./dir
-l LOGD: directory where runtime logs are written.  Default : ./logs

Arguments:
  STEP: one of: evaluate, process, all

Analysis proceeds in four steps:
* `evaluate` recursively scans entire filesystem to collect information about all files.  Generates `rawstat` file
* `process` parses the `rawstat` file to generate `filestat` file

Step `all` evaluates both steps

Logs are generated by the evaluate_volume step and are written to logs/evaluate_volume.XXX.err and .out
These are used to identify directories which had permission errors, which is output to STDERR
Note summary is removed because in v2 summaries are generated for all volumes
EOF

# Default values
DATD="dat"
LOGD="logs"
PYTHON="python3" # we don't provide a way to set this for now, rely on PATH
TIMESTAMP=$(date +%Y%m%d)

# http://wiki.bash-hackers.org/howto/getopts_tutorial
while getopts ":hdV:T:N:t:l:" opt; do
  case $opt in
    h)
      echo "$USAGE"
      exit 0
      ;;
    d)  # example of binary argument
      DRYRUN="d"
      ;;
    V) 
      VOLUME=$OPTARG
      ;;
    T) 
      TIMESTAMP=$OPTARG
      ;;
    N) 
      VOLNAME=$OPTARG
      ;;
    t) 
      DATD=$OPTARG
      ;;
    l) 
      LOGD=$OPTARG
      ;;
    \?)
      >&2 echo "Invalid option: -$OPTARG" 
      >&2 echo "$USAGE"
      exit 1
      ;;
    :)
      >&2 echo "Option -$OPTARG requires an argument." 
      >&2 echo "$USAGE"
      exit 1
      ;;
  esac
done
shift $((OPTIND-1))

if [ "$#" -ne 1 ]; then
    >&2 echo Error: Wrong number of arguments
    >&2 echo "$USAGE"
    exit 1
fi

STEP=$1

if [ $STEP != "evaluate" ] && [ $STEP != "process" ] && [ $STEP != "all" ] ; then
    >&2 echo Unknown step : $STEP
    >&2 echo "$USAGE"
    exit 1
fi

# Confirm python version 3. From https://stackoverflow.com/questions/6141581/detect-python-version-in-shell-script
PYTHON_MAJOR_VERSION=`$PYTHON -c 'import sys; version=sys.version_info[:3]; print("{0}".format(*version))'`
if [ $PYTHON_MAJOR_VERSION != "3" ]; then
    >&2 echo ERROR: Require python 3
    PY=$(which $PYTHON)
    >&2 echo $PY is version $PYTHON_MAJOR_VERSION
    >&2 echo Quitting
    exit 1
fi

if [ -z $VOLUME ]; then
    >&2 echo Volume name \(-V\) required
    exit 1
fi
if [ -z $VOLNAME ]; then
    >&2 echo Volume short name \(-N\) required
    exit 1
fi

mkdir -p $LOGD
mkdir -p $DATD

function run_cmd {
    CMD=$1

    NOW=$(date)
    if [ "$DRYRUN" == "d" ]; then
        >&2 echo [ $NOW ] Dryrun: $CMD
    else
        >&2 echo [ $NOW ] Running: $CMD
        eval $CMD
        test_exit_status
        NOW=$(date)
        >&2 echo [ $NOW ] Completed successfully
    fi
}

function confirm {
    FN=$1
    WARN=$2
    NOW=$(date)
    if [ ! -s $FN ]; then
        if [ -z $WARN ]; then
            >&2 echo [ $NOW ] ERROR: $FN does not exist or is empty
            exit 1
        else
            >&2 echo [ $NOW ] WARNING: $FN does not exist or is empty.  Continuing
        fi
    fi
}

# Called after running scripts to catch fatal (exit 1) errors
# works with piped calls ( S1 | S2 | S3 > OUT )
function test_exit_status {
    rcs=${PIPESTATUS[*]};
    for rc in ${rcs}; do
        if [[ $rc != 0 ]]; then
            >&2 echo Fatal ERROR.  Exiting
            exit $rc;
        fi;
    done
}

function evaluate_permission_denied {
    LOGERR=$1
    NERR=$(grep "Permission denied" $LOGERR | wc -l)
    test_exit_status
    if [[ "$NERR" != "0" ]]; then
        >&2 echo NOTE: $NERR counts of \"Permission denied\" in error log
    fi
}

function evaluate_volume {
    OUT=$1

    NOW=$(date)
    >&2 echo [ $NOW ] Running step evaluate

    LOGERR="$LOGD/${VOLNAME}.${TIMESTAMP}.evaluate_volume.err"
    LOGOUT="$LOGD/${VOLNAME}.${TIMESTAMP}.evaluate_volume.out"

    >&2 echo "     Analyzing $VOLUME"
    >&2 echo "     Writing to $OUT"
    >&2 echo "     Logs to $LOGERR and $LOGOUT"
    CMD="bash src/evaluate_fs.sh -o $OUT $VOLUME > $LOGOUT 2> $LOGERR"
    run_cmd "$CMD"

    if [ "$DRYRUN" != "d" ]; then
        evaluate_permission_denied $LOGERR
    fi
}

function process_stats {
    DAT=$1
    OUT=$2
    VOLNAME=$3
    TIMESTAMP=$4
    NOW=$(date)
    >&2 echo [ $NOW ] Running step process

    CMD="$PYTHON src/parse_fs.py -i $DAT  -o $OUT -V $VOLNAME -T $TIMESTAMP"
    run_cmd "$CMD"

    >&2 echo Written to $OUT
}

RAW="$DATD/${VOLNAME}.${TIMESTAMP}.rawstat.gz"  
PRO="$DATD/${VOLNAME}.${TIMESTAMP}.filestat.gz"  

SIZE=$(df -h -B G $VOLUME)
>&2 echo Filesystem stats:
>&2 echo "$SIZE"

if [ $STEP == "evaluate" ] || [ $STEP == "all" ]; then
    evaluate_volume $RAW
fi

if [ $STEP == "process" ] || [ $STEP == "all" ] || [ $STEP == "posteval" ]; then
    process_stats $RAW $PRO $VOLNAME $TIMESTAMP
fi

NOW=$(date)
>&2 echo [ $NOW ] Completed successfully
