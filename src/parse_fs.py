#!/usr/bin/python

# Matthew Wyczalkowski
# m.wyczalkowski@wustl.edu
# Washington University School of Medicine

# Assume input columns are:
#   file_name file_type file_size owner_name time_mod hard_links
#
# Retain only regular files. For these, extract
#   1) dirname, 2) filename, 3) extension.  Note that filename includes extension
#
# Write the following columns:
#   volume_name, timestamp, dirname, filename, ext, file_type, file_size, owner_name, time_mod, hard_links

import sys, os, gzip

def main():
    from optparse import OptionParser
    usage_text = """usage: %prog [options] ...
        Process list of generated by stat of file options
        """

    parser = OptionParser(usage_text, version="$Revision: 1.2 $")
    parser.add_option("-i", dest="infn", default="stdin", help="Input filename.  Reads .gz")
    parser.add_option("-o", dest="outfn", default="stdout", help="Output filename.  Can write .gz")
    parser.add_option("-V", dest="volume_name", default="VOLUME", help="Volume name.  Written verbatim to first column")
    parser.add_option("-T", dest="timestamp", default="TIMESTAMP", help="Timestamp string.  Written verbatim to second column")

    (options, params) = parser.parse_args()

    if options.infn == "stdin":
        f = sys.stdin
        print("Reading stdin")
    else:
        base, ext = os.path.splitext(options.infn)
        if ext == ".gz": 
            print("Reading gz")
#  Changing encoding to avoid UnicodeDecodeError: https://stackoverflow.com/questions/19699367/unicodedecodeerror-utf-8-codec-cant-decode-byte
            f = gzip.open(options.infn, 'rt', encoding = "ISO-8859-1")   
        else:
            print("Reading data")
            f = open(options.infn, 'r', encoding='ISO-8859-1')

    if options.outfn == "stdout":
        o = sys.stdout
    else:
        base, ext = os.path.splitext(options.outfn)
        if ext == ".gz":
            o = gzip.open(options.outfn, 'wt')
        else:
            o = open(options.outfn, "w")

# Make sure this works with input and output being either compressed or uncompressed
# bytes vs. str: https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3
#    b = bytes(mystring, 'utf-8')
    outstr='\t'.join( ("# volume_name", "timestamp", "dirname", "filename", "ext", "file_type", "file_size", "owner_name", "time_mod", "hard_links"))+"\n"
    o.write(outstr)

    for line in f.readlines():
#     1  file_name 
#     2  file_type
#     3  file_size
#     4  owner_name
#     5  time_mod
#     6  hard_links

        try:
            (file_name, file_type, file_size, owner_name, time_mod, hard_links) = line.rstrip().split("\t")
        except ValueError as e:
#        ValueError: not enough values to unpack (expected 6, got 1)
#       This may happen if there are weird characters in filenames (e.g., "?") which make the printf in evaluate_fs.sh
            print("ValueError {0} in ".format(e), options.infn," : ", line)
            print("Skipping")
            continue

        # Skip headers
        if file_name.startswith("#"): continue

        # Process only regular files
        if file_type != "regular file": 
            continue

        # From a complete file_name, extract 1) dirname, 2) filename, 3) extension.  Note that filename includes extension
        dirname = os.path.dirname(file_name)
        filename = os.path.basename(file_name)
        dirname = os.path.dirname(file_name)
        base, ext = os.path.splitext(filename)

        # Try to make extensions meaningful:
        #   * if ends in .gz, include the "upstream" extenstion (e.g., .tar.gz)
        #   * If there is no extension, filename is extension (to capture e.g. "core")
        if ext == ".gz":
            base, ext2 = os.path.splitext(base)
            ext = ext2 + ext
        if ext == "":
            ext = base 

        outstr = '\t'.join( (options.volume_name, options.timestamp, dirname, filename, ext, file_type, file_size, owner_name, time_mod, hard_links))+"\n"
        o.write(outstr)

    f.close()
    o.close()

if __name__ == '__main__':
    main()

